#! /bin/bash

# Creates a .out and .csv file of the critical exponents,
# constant of dissipation, mass and aspect ratio.
# Copies data files to local.

# Creates plo scripts for viscosity scaling figures.
# Executes plo scripts.
# Copies plo scripts to local.
# Copies figures to local.

## PARAMETRISATION

NU=${NUMBER-1024} # for simulations with N=NU particles
K=${KD-k500} # for simulations with kd=K
MA=${MASS-l100} # for simulations with m=MA

LA=${LAB-umea_lab} # tp.umu.se host
TP=${LABPATH-/home/yketa/Desktop/Elli-mpi} # tp.umu.se path to shearing simulations directory

LP=${LOCALPATH-/Users/yketa/Cours/ENS/M1/Stage/UmeaÌŠ/simulations-shear} # local path to relaxation simulations directory

CR=${CREXP-cr_exp_ouputs-shear} # name of the critical exponents data files directory in TP and local
ZR=${ZROUT-contact_outputs-shear} # name of the contact numbers data files directory in TP and local
OV=${OVOUT-omegav_outputs-shear} # name of the ratio of rotational and translational velocities data files directory in TP and local
PL=${PLOT-scale_plots-shear} # name of the plo scripts directory in TP and local
FI=${FIG-scale_figs-shear} # name of the figures directory in TP and local

## SCRIPT

ssh $LA "bash -s $NU $K $MA $TP $CR $ZR $OV $PL $FI" << 'EOF' # executes on tp.umu.se

	NU=$1 # simulations with N=NU particles
	shift
	K=$1 # simulations with kd=K
	shift
	MA=$1 # simulations with m=MA
	shift

	TP=$1 # tp.umu.se path to shearing simulations directory
	shift
	CR=$1 # critical exponents data files directory in TP
	shift
	ZR=$1 # contact numbers data files directory in TP
	shift
	OV=$1 # ratio of rotational and translational velocities data files directory in TP and local
	shift
	PL=$1 # plo scripts directory in TP
	shift
	FI=$1 # figures directory in TP
	shift

	if [ ! -d ${TP}/data ]; then
		echo "Shearing simulations data directory does not exist."
		exit 0
	elif [ ! -f ${TP}/bin/tot ]; then
		echo "Shearing simulations directory does not contain bin/tot."
		exit 0
	elif [ ! -x "$(command -v plo)" ]; then
		echo "Host does not have the command plo."
		exit 0
	fi

	cd ${TP} # directory of the data files of the shearing simulations
	echo "Simulations directory: $(pwd) on $(whoami)@$HOSTNAME"
	printf "\n"
	
	mkdir -p tot
	if [ ! -d ltot ] && [ -f bin/ltot ]; then
		mkdir ltot
	fi
	mkdir -p ttime

	mkdir -p $CR
	mkdir -p $ZR
	mkdir -p $OV

	mkdir -p $PL
	mkdir -p ${PL}/p_scale
	mkdir -p ${PL}/rheo
	mkdir -p ${PL}/p_cr_exp
	mkdir -p ${PL}/p_cr_exp_gdmax
	mkdir -p ${PL}/ori_gd
	mkdir -p ${PL}/ori_el
	mkdir -p ${PL}/orij
	mkdir -p ${PL}/omegagd_gd
	mkdir -p ${PL}/omegagd_el
	mkdir -p ${PL}/omegagd_el/omegagd_phi
	for dir in prolate oblate; do
		mkdir -p ${PL}/ori_el/${dir}
		mkdir -p ${PL}/orij/${dir}
		mkdir -p ${PL}/omegagd_el/${dir}
	done
	mkdir -p ${PL}/z
	mkdir -p ${PL}/z/z_phi
	mkdir -p ${PL}/z/prolate
	mkdir -p ${PL}/z/oblate
	if [ -d ltot ]; then
		mkdir -p ${PL}/zr_phi
		mkdir -p ${PL}/grc_scale
		mkdir -p ${PL}/grc_el
		mkdir -p ${PL}/grc_el/prolate
		mkdir -p ${PL}/grc_el/oblate
		mkdir -p ${PL}/vijrc_gd
		mkdir -p ${PL}/vijrc_el
		mkdir -p ${PL}/vijrc_el/prolate
		mkdir -p ${PL}/vijrc_el/oblate
		mkdir -p ${PL}/S2_gd
		mkdir -p ${PL}/S2_el
		mkdir -p ${PL}/S2_el/prolate
		mkdir -p ${PL}/S2_el/oblate
	fi
	mkdir -p ${PL}/omegav_gd
	mkdir -p ${PL}/omegav_el
	mkdir -p ${PL}/omegav_el/prolate
	mkdir -p ${PL}/omegav_el/oblate
	mkdir -p ${PL}/omegav_phiJ

	mkdir -p $FI
	mkdir -p ${FI}/p_scale
	mkdir -p ${FI}/p_scale/p-phi
	mkdir -p ${FI}/p_scale/p-dphi-scale
	mkdir -p ${FI}/p_scale/etap-phi
	mkdir -p ${FI}/p_scale/etap-phieff
	mkdir -p ${FI}/p_scale/etap-phieff_graph
	mkdir -p ${FI}/rheo
	mkdir -p ${FI}/rheo/etap
	mkdir -p ${FI}/rheo/bp
	mkdir -p ${FI}/p_cr_exp
	mkdir -p ${FI}/p_cr_exp/beta
	mkdir -p ${FI}/p_cr_exp/phij
	mkdir -p ${FI}/p_cr_exp_gdmax
	mkdir -p ${FI}/p_cr_exp_gdmax/beta
	mkdir -p ${FI}/p_cr_exp_gdmax/phij
	mkdir -p ${FI}/p_cr_exp_gdmax/chisq
	mkdir -p ${FI}/ori
	mkdir -p ${FI}/ori/ori_phi
	mkdir -p ${FI}/orij
	mkdir -p ${FI}/omegagd
	mkdir -p ${FI}/omegagd/omegagd_phi_gd
	mkdir -p ${FI}/omegagd/omegagd_phieff_gd
	mkdir -p ${FI}/omegagd/omegagd_phi_el
	for dir in prolate oblate; do
		mkdir -p ${FI}/ori/${dir}
		for ax in $(seq 0 2); do
			mkdir -p ${FI}/ori/${dir}/ori${ax}_phi
			mkdir -p ${FI}/ori/${dir}/ori${ax}al_phi
			mkdir -p ${FI}/ori/${dir}/ori${ax}_phieff
			mkdir -p ${FI}/ori/${dir}/ori${ax}al_phieff
		done
		mkdir -p ${FI}/orij/${dir}
		mkdir -p ${FI}/orij/${dir}/orij_phi
		mkdir -p ${FI}/orij/${dir}/orijal_phi
		mkdir -p ${FI}/orij/${dir}/orij_phieff
		mkdir -p ${FI}/orij/${dir}/orijal_phieff
		mkdir -p ${FI}/omegagd/${dir}
	done
	mkdir -p ${FI}/z
	mkdir -p ${FI}/z/z_phi
	mkdir -p ${FI}/z/prolate
	mkdir -p ${FI}/z/oblate
	if [ -d ltot ]; then
		mkdir -p ${FI}/zr_phi
		mkdir -p ${FI}/grc_scale
		mkdir -p ${FI}/grc_scale/grc-phi
		mkdir -p ${FI}/grc_scale/grc-dphi-scale
		mkdir -p ${FI}/grc_phi_el
		mkdir -p ${FI}/grc_phi_el/prolate
		mkdir -p ${FI}/grc_phi_el/oblate
		mkdir -p ${FI}/vijrc_phi_gd
		mkdir -p ${FI}/vijrc_phi_el
		mkdir -p ${FI}/vijrc_phi_el/prolate
		mkdir -p ${FI}/vijrc_phi_el/oblate
		mkdir -p ${FI}/S2_phi_gd
		mkdir -p ${FI}/S2_phi_el
		mkdir -p ${FI}/S2_phi_el/prolate
		mkdir -p ${FI}/S2_phi_el/oblate
	fi
	mkdir -p ${FI}/omegav/omegav_phi_gd
	mkdir -p ${FI}/omegav/omegav_phi_el
	mkdir -p ${FI}/omegav/omegav_phi_el/prolate
	mkdir -p ${FI}/omegav/omegav_phi_el/oblate
	mkdir -p ${FI}/omegav_phiJ


	while (( ${#NU} < 4 )); do
		NU=0${NU} # number of particles with adequate number of zeros
	done
	NNU=${#NU} # number of digits of the number of particles with adequate number of zeros
	declare -A args # declares the hash table args
	args=(["N"]="0" ["r"]="$((2+$NNU))" ["GD"]="$((9+$NNU))" ["KD"]="$((16+$NNU))" ["M"]="$((22+$NNU))" ["EL"]="$((29+$NNU))") # hash table of the positions of the arguments

	declare -A exponents # declares the hash table exponents
	exponents=(["a"]="e-11" ["b"]="e-10" ["c"]="e-9" ["d"]="e-8" ["e"]="e-7" ["f"]="e-6" ["g"]="e-5" ["h"]="e-4" ["i"]="e-3" ["j"]="e-2" ["k"]="e-1" ["l"]="e0" ["m"]="e1") # hash table of the exponents

	# creation of the output files

	echo "Creating repertoire of data files."
	files=(`ls data | grep $NU | grep KD${K} | grep M${MA}`) # data files corresponding to completed or running shearing simulations and our parameters of interest
	
	files_tot=($(for file in ${files[@]}; do if [ ! -f tot/${file}.tot ] || [ data/$file -nt tot/${file}.tot ]; then echo $file; fi; done)) # data files which do not have a corresponding .tot file or which are newer than the corresponding .tot file
	if (( "${#files_tot[@]}" > 0 )); then # some data files have to be converted to .tot files
		for file in $(seq 0 $((${#files_tot[@]}-1))); do
			echo -ne "Creating or renewing ${#files_tot[@]} .tot files. ($(($file+1))/${#files_tot[@]})\r"
			echo data/${files_tot[$file]} | bin/tot > tot/${files_tot[$file]}.tot
		done
		echo ""
	fi

	if [ -d ltot ]; then
		files_ltot=($(for file in ${files[@]}; do if [ ! -f ltot/${file}.ltot ] || [ data/$file -nt ltot/${file}.ltot ]; then echo $file; fi; done)) # data files which do not have a corresponding .ltot file or which are newer than the corresponding .ltot file
		if (( "${#files_ltot[@]}" > 0 )); then # some data files have to be converted to .ltot files
			for file in $(seq 0 $((${#files_ltot[@]}-1))); do
				echo -ne "Creating or renewing ${#files_ltot[@]} .ltot files. ($(($file+1))/${#files_ltot[@]})\r"
				echo Lat/${files_ltot[$file]} | bin/ltot > ltot/${files_ltot[$file]}.ltot
			done
			echo ""
		fi
	fi

	files_ttime=($(for file in ${files[@]}; do if [ ! -f ttime/${file}.ttime ] || [ data/$file -nt ttime/${file}.ttime ]; then echo $file; fi; done)) # data files which do not have a corresponding .ttime file or which are newer than the corresponding .ttime file
	if (( "${#files_ttime[@]}" > 0 )); then # some data files have to be converted to .tot files
		for file in $(seq 0 $((${#files_ttime[@]}-1))); do
			echo -ne "Creating or renewing ${#files_ttime[@]} .ttime files. ($(($file+1))/${#files_ttime[@]})\r"
			echo data/${files_ttime[$file]} | bin/ttime > ttime/${files_ttime[$file]}.ttime
		done
		echo ""
	fi

	printf "\n"

	# per aspect ratio

	EL=($(for file in ${files[@]}; do echo ${file:${args[EL]}:3}; done | sort)) # array of the aspect ratios
	_EL=() # aspect ratios which have been already treated

	# critical exponents for the pressure
	p_col0=( N kd m alpha ) # external parameters
	p_col1=( phij phijsd beta betasd q qsd h hsd chisq ) # data to be measured with Levenberg-Marquadt
	p_col2=( A Asd c csd chisqb ) # data to be measured with Levenberg-Marquadt
	p_col3=( Ag cg ) # data to be measured graphically
	p_col=( ${p_col0[@]} ${p_col1[@]} ${p_col2[@]} ${p_col3[@]} ) # data to be measured
	p_col_gdmax=( ${p_col0[@]} gdmax ${p_col1[@]} ) # data to be measured depending on the maximum shear rate
	declare -A p_hashcol # hash table of the element in col
	for ind in $(seq 0 $((${#p_col[@]}-1))); do
		p_hashcol+=( [${p_col[$ind]}]=$ind ) # index of the elements in col
	done
	> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.out # plo data
	> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.out # plo data
	echo icol $(for el in ${p_col[@]}; do echo $el | ( [[ ${el: -2} == sd ]] && sed s/$el/?/ || cat); done) >> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.out
	echo icol $(for el in ${p_col_gdmax[@]}; do echo $el | ( [[ ${el: -2} == sd ]] && sed s/$el/?/ || cat); done) >> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.out
	> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.csv # csv data
	> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.csv # csv data
	echo ${p_col[@]} | sed s/' '/','/g >> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.csv
	echo ${p_col_gdmax[@]} | sed s/' '/','/g >> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.csv
	declare -A p_cr_exp # hash tables of the critical exponents per aspect ratio

	# critical exponents for the correlation of rotational and translational velocities
	if [ -d ltot ]; then
		grc_col0=( N kd m alpha ) # external parameters
		grc_col1=( phic phicsd beta betasd q qsd h hsd chisq ) # data to be measured with Levenberg-Marquadt
		grc_col=( ${grc_col0[@]} ${grc_col1[@]} ) # data to be measured
		declare -A grc_hashcol # hash table of the element in col
		for ind in $(seq 0 $((${#grc_col[@]}-1))); do
			grc_hashcol+=( [${grc_col[$ind]}]=$ind ) # index of the elements in col
		done
		> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.out # plo data
		echo "icol ${grc_col[@]}" >> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.out
		> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.csv # csv data
		echo ${grc_col[@]} | sed s/' '/','/g >> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.csv
		declare -A grc_cr_exp # hash tables of the critical exponents per aspect ratio
	fi

	# parameters for scaling analysis
	gdotmin=5e-7 # minimum shear rate
	gdotmax=5e-5 # maximum shear rate
	xmax=0.4 # maximum absolute value of the scaling variable used in the fit

	for el in $(seq 0 $((${#EL[@]}-1))); do

		if [[ ! "${_EL[@]}" =~ "${EL[$el]}" ]]; then # if the aspect ration ${EL[$el]} has not been treated yet

			_EL+=(${EL[$el]}) # we add the current aspect ratio to the already treated array

			files_EL=($(for file in ${files[@]}; do echo $file | grep EL${EL[$el]}; done)) # files to treat for the current value of the aspect ratio
			echo "Reading from ${#files_EL[@]} files with alpha=${EL[$el]:0:1}.${EL[$el]:1:2}."

			GD_=() # arrays of the shear strain rates (with Olsson's notation)
			for file in ${files_EL[@]}; do
				if [[ ! "${GD_[@]}" =~ "${file:${args[GD]}:4}" ]]; then
					GD_+=(${file:${args[GD]}:4})
				fi
			done
			GD_=($(for gd in ${GD_[@]}; do echo $gd; done | sort)) # sorted shear strain rates (with Olsson's notation)
			GD=($(for gd in ${GD_[@]}; do echo ${gd:1:1}.${gd:2:2}${exponents[${gd:0:1}]}; done)) # arrays of the shearing strain rates

			# p_cr_exp_*_KD*_M*.* (measurements are separed to keep errors in one of the measures from avoiding other measures)

			p_crexp=() # critical expontents

			p_crexp1=( `( plo <<EOF2
< "cat tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

cal gdotmax $gdotmax
cal gdotmin $gdotmin
cal xmax $xmax

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal \\$q 0.183347
cal \\$a0 -2.82432
cal \\$a1 4.19327
cal \\$rhoc 0.707465
cal \\$h -0.190358
cal \\$a2 -5.98509
cal \\$a3 12.8789 
cal \\$a4 24.9358
cal \\$a5 0

cal X (phi-\\$rhoc)*gdot^\\$h
cal Sel abs(X)<xmax&engr>3&gdot<=gdotmax&gdot>=gdotmin

for nn 1 10
icol q a0 a1 rhoc h a2 a3 a4 a5 qsd a0sd a1sd rhocsd hsd a2sd a3sd a4sd a5sd chisq
get "lmarqsd(pe,pe?*sdfact,
(gdot^\\$q):gk*exp(\\$a0+\\$a1*((phi-\\$rhoc):rd*(gdot^\\$h):gh):gr+\\$a2*(gr*gr):gr2+\\$a3*(gr*gr2):gr3+\\$a4*(gr2*gr2):gr4+\\$a5*gr2*gr3):atot,
ln(gdot)*gk*atot,
gk*atot,
gk*gr*atot,
gk*gh*(-1)*(\\$a1+\\$a2*2*gr+\\$a3*3*gr2+\\$a4*4*gr3+\\$a5*5*gr4):tot12345*atot,
gk*ln(gdot)*gh*rd*tot12345*atot,
gk*gr2*atot,
gk*gr3*atot,
gk*gr4*atot,
gk*gr2*gr3*atot,
Sel)
end

cal beta (q[q.n1-1]-1)/h[h.n1-1]
cal betasd beta*sqrt((qsd[qsd.n1-1]/q[q.n1-1])^2+(hsd[hsd.n1-1]/h[h.n1-1])^2)

list rhoc[rhoc.n1-1] rhocsd[rhocsd.n1-1] beta betasd q[q.n1-1] qsd[qsd.n1-1] h[h.n1-1] hsd[hsd.n1-1] chisq[chisq.n1-1]
exit
EOF2
			) | grep -v Plo | grep -v '...>'` ) # critical exponents, inferred from the Levenbergâ€“Marquardt least squared curve fitting method
			if [[ "${#p_crexp1[@]}" = "${#p_col1[@]}" ]]; then # no errors in the measurement
				p_crexp+=( ${p_crexp1[@]} )
			else
				p_crexp+=( $(for i in $(seq 1 ${#p_col1[@]}); do echo 0; done) )
			fi

			p_crexp2=( `( plo <<EOF2
< "cat tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

cal gdotmax $gdotmax
cal gdotmin $gdotmin
cal xmax $xmax

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal rhoc ${p_crexp[0]}
cal beta ${p_crexp[2]}
cal q ${p_crexp[4]}
cal h ${p_crexp[6]}

cal xminetap rhoc-0.05
cal xmaxetap rhoc+0.02
cal Selb rho>=xminetap&rho<=xmaxetap&pe>0

cal w -0.5*h/q

cal \\$A 0.0004
cal \\$c 1.5

# cal Xb (phi-rhoc)*gdot^h
# cal Selb abs(Xb)<xmax&engr>3&gdot<=gdotmax&gdot>=gdotmin

for nn 1 10
icol A c Asd csd chisqb
get "lmarqsd(pe,pe?*sdfact,
gdot*\\$A*(rhoc-phi+\\$c*energy^w):btot^(-beta),
gdot*btot^(-beta),
-gdot*\\$A*beta*energy^w*btot^(-beta-1),
Selb)
end

list A[A.n1-1] Asd[Asd.n1-1] c[c.n1-1] csd[csd.n1-1] chisqb[chisqb.n1-1]
exit
EOF2
			) | grep -v Plo | grep -v '...>'` ) # critical exponents, inferred from the Levenbergâ€“Marquardt least squared curve fitting method
			if [[ "${#p_crexp2[@]}" = "${#p_col2[@]}" ]]; then # no errors in the measurement
				p_crexp+=( ${p_crexp2[@]} )
			else
				p_crexp+=( $(for i in $(seq 1 ${#p_col2[@]}); do echo 0; done) )
			fi

			p_crexp3=( `( plo <<EOF2
< "cat tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

cal gdotmax $gdotmax
cal gdotmin $gdotmin
cal xmax $xmax

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal rhoc ${p_crexp[0]}
cal beta ${p_crexp[2]}
cal q ${p_crexp[4]}
cal h ${p_crexp[6]}

cal xminetap rhoc-0.05
cal xmaxetap rhoc+0.02
cal Selb rho>=xminetap&rho<=xmaxetap&pe>0

cal w -0.5*h/q

cal etap select(pe/gdot,Selb)

cal etap1 etap.min
cal etap2 etap.max

cal E1 select(energy,pe/gdot=etap1&Selb)
cal E1 E1[0]
cal E2 select(energy,pe/gdot=etap2&Selb)
cal E2 E2[0]
cal phi1 select(rho,pe/gdot=etap1&Selb)
cal phi1 phi1[0]
cal phi2 select(rho,pe/gdot=etap2&Selb)
cal phi2 phi2[0]

cal C (((rhoc-phi1)/(E1^w)+(phi2-rhoc)/(E2^w))/((etap1^(-1/beta))/(E1^w)-(etap2^(-1/beta))/(E2^w)))^beta
cal d ((etap2/C)^(-1/beta)+phi2-rhoc)/(E2^w)

list C d
exit
EOF2
			) | grep -v Plo | grep -v '...>'` ) # critical exponents, measured graphically
			if [[ "${#p_crexp3[@]}" = "${#p_col3[@]}" ]]; then # no errors in the measurement
				p_crexp+=( ${p_crexp3[@]} )
			else
				p_crexp+=( $(for i in $(seq 1 ${#p_col3[@]}); do echo 0; done) )
			fi

			p_cr_exp+=( [${EL[$el]}]="${p_crexp[@]}" )
			
			values="${NU} ${K:1:1}.${K:2:2}${exponents[${K:0:1}]} ${MA:1:1}.${MA:2:2}${exponents[${MA:0:1}]} ${EL[$el]:0:1}.${EL[$el]:1:2} ${p_crexp[@]} " # values
			values=( $values )
			if [[ "${#values[@]}" = "${#p_col[@]}" ]]; then # no error in the determination of the critical exponents (this should always be true because of the previous tests)
				echo ${values[@]} >> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.out # writes in plo parsed file
				echo ${values[@]} | sed s/' '/','/g >> ${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.csv # writes in csv parsed data
			fi

			# p_cr_exp_gdmax_*_KD*_M*.*

			if (( "${#GD[@]}" > 1 )); then # we need at least 2 shear rates to make the scaling analysis
				for gdmax in ${GD[@]:1}; do # we calculate critical exponents for every shear rate tested as the maximum

					p_crexp=( `( plo <<EOF2
< "cat tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

cal gdotmax $gdmax
cal xmax $xmax

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal \\$q 0.183347
cal \\$a0 -2.82432
cal \\$a1 4.19327
cal \\$rhoc 0.707465
cal \\$h -0.190358
cal \\$a2 -5.98509
cal \\$a3 12.8789 
cal \\$a4 24.9358
cal \\$a5 0

cal X (phi-\\$rhoc)*gdot^\\$h
cal Sel abs(X)<xmax&engr>3&gdot<=gdotmax

for nn 1 10
icol q a0 a1 rhoc h a2 a3 a4 a5 qsd a0sd a1sd rhocsd hsd a2sd a3sd a4sd a5sd chisq
get "lmarqsd(pe,pe?*sdfact,
(gdot^\\$q):gk*exp(\\$a0+\\$a1*((phi-\\$rhoc):rd*(gdot^\\$h):gh):gr+\\$a2*(gr*gr):gr2+\\$a3*(gr*gr2):gr3+\\$a4*(gr2*gr2):gr4+\\$a5*gr2*gr3):atot,
ln(gdot)*gk*atot,
gk*atot,
gk*gr*atot,
gk*gh*(-1)*(\\$a1+\\$a2*2*gr+\\$a3*3*gr2+\\$a4*4*gr3+\\$a5*5*gr4):tot12345*atot,
gk*ln(gdot)*gh*rd*tot12345*atot,
gk*gr2*atot,
gk*gr3*atot,
gk*gr4*atot,
gk*gr2*gr3*atot,
Sel)
end

cal beta (q[q.n1-1]-1)/h[h.n1-1]
cal betasd beta*sqrt((qsd[qsd.n1-1]/q[q.n1-1])^2+(hsd[hsd.n1-1]/h[h.n1-1])^2)

list rhoc[rhoc.n1-1] rhocsd[rhocsd.n1-1] beta betasd q[q.n1-1] qsd[qsd.n1-1] h[h.n1-1] hsd[hsd.n1-1] chisq[chisq.n1-1]
exit
EOF2
					) | grep -v Plo | grep -v '...>'` ) # critical exponents, inferred from the Levenbergâ€“Marquardt least squared curve fitting method

					values="${NU} ${K:1:1}.${K:2:2}${exponents[${K:0:1}]} ${MA:1:1}.${MA:2:2}${exponents[${MA:0:1}]} ${EL[$el]:0:1}.${EL[$el]:1:2} $gdmax ${p_crexp[@]} " # values
					values=( $values )
					echo ${values[@]}
					if [[ "${#values[@]}" = "${#p_col_gdmax[@]}" ]]; then
						echo ${values[@]} >> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.out # writes in plo parsed file
						echo ${values[@]} | sed s/' '/','/g >> ${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.csv # writes in csv parsed data
					fi

				done
			fi

			# p_scale_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot
getenv GDOTMAX $gdotmax
getenv GDOTMIN $gdotmin
getenv XMAX $xmax

icol gd
`for gd in ${GD[@]}; do echo $gd; done`

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal \$q 0.183347
cal \$a0 -2.82432
cal \$a1 4.19327
cal \$rhoc 0.707465
cal \$h -0.190358
cal \$a2 -5.98509
cal \$a3 12.8789 
cal \$a4 24.9358
cal \$a5 0

cal X (phi-\$rhoc)*gdot^\$h
cal Sel abs(X)<\`XMAX&engr>3&gdot<=\`GDOTMAX&gdot>=\`GDOTMIN

for nn 1 10
icol q a0 a1 rhoc h a2 a3 a4 a5 qsd a0sd a1sd rhocsd hsd a2sd a3sd a4sd a5sd chisq
get "lmarqsd(pe,pe?*sdfact,
(gdot^\$q):gk*exp(\$a0+\$a1*((phi-\$rhoc):rd*(gdot^\$h):gh):gr+\$a2*(gr*gr):gr2+\$a3*(gr*gr2):gr3+\$a4*(gr2*gr2):gr4+\$a5*gr2*gr3):atot,
ln(gdot)*gk*atot,
gk*atot,
gk*gr*atot,
gk*gh*(-1)*(\$a1+\$a2*2*gr+\$a3*3*gr2+\$a4*4*gr3+\$a5*5*gr4):tot12345*atot,
gk*ln(gdot)*gh*rd*tot12345*atot,
gk*gr2*atot,
gk*gr3*atot,
gk*gr4*atot,
gk*gr2*gr3*atot,
Sel)
end

cal beta (q[q.n1-1]-1)/h[h.n1-1]
cal betasd beta*sqrt((qsd[qsd.n1-1]/q[q.n1-1])^2+(hsd[hsd.n1-1]/h[h.n1-1])^2)

cal xminetap \$rhoc-0.05
cal xmaxetap \$rhoc+0.02
cal Selb rho>=xminetap&rho<=xmaxetap&pe>0

cal w -0.5*h[h.n1-1]/q[q.n1-1]
cal phi_j rhoc[rhoc.n1-1]


fig a

gr 0,,gd.n1-1 pe rho -err pe? -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 600+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr gd.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr gd.n1+3 -mark 500 5000 -text "\${\scriptstyle \alpha=%6.2f}\$" alpha[0]

xl rho.min-0.1 - lin
yl - - log

ctext pe \$p_e\$
ctext rho \$\phi\$

latexps ${TP}/${FI}/p_scale/p-phi/p-phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig b

cal X (rho-\$rhoc)*gdot^\$h
cal Sel abs(X)<\`XMAX&engr>3&gdot<=\`GDOTMAX&gdot>=\`GDOTMIN
cal etapq select(pe/gdot^\$q,Sel)

cal yetapqmin exp(2*ln(etapq.min)-ln(etapq.max))
cal yetapqmax exp(2*ln(etapq.max)-ln(etapq.min))

gr 0,,gd.n1-1 pe/gdot^\$q X -err sqrt(pe?^2+(pe*ln(gdot)*qsd[qsd.n1-1])^2)/gdot^\$q -sel gdot=gd[#]&Sel

icol x
for i -110*\`XMAX 110*\`XMAX get i/100
gr gd.n1 exp(\$a0+x*(\$a1+x*(\$a2+x*(\$a3+x*(\$a4+x*\$a5))))) x -Line

gr gd.n1 -mark 800 800 -text "\${\scriptscriptstyle f(X)=\exp\left(\sum_{i=0}^{5}a_iX^i\right)}\$"
gr gd.n1+1 -mark 6000 800 -text "\${\scriptstyle \phi_{\scriptscriptstyle J}=%6.4f\pm%6.5f}\$" rhoc[rhoc.n1-1] rhocsd[rhocsd.n1-1]
gr gd.n1+2 -mark 800 5800 -text "\${\scriptstyle q_p=%5.3f\pm%5.4f,~ h_p=%5.3f\pm%5.4f}\$" q[q.n1-1] qsd[qsd.n1-1] h[h.n1-1] hsd[hsd.n1-1]
gr gd.n1+3 -mark 800 6300 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g,~ \alpha=%6.2f}\$" N[0] kd[0] m[0] alpha[0]
gr gd.n1+4 -mark 800 5300 -text "\${\scriptstyle \chi^2/DOF=%3.2f}\$" chisq[chisq.n1-1]

xl -1.25*\`XMAX 1.25*\`XMAX lin
yl yetapqmin yetapqmax log

ctext pe/gdot^\$q \$p_e/\dot\gamma^{q_p}\$
ctext X \$(\phi-\phi_J)\dot\gamma^{h_p}\$

latexps ${TP}/${FI}/p_scale/p-dphi-scale/p-dphi-scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig c

cal etap select(pe/gdot,rho>=xminetap&rho<=xmaxetap)

cal yetapmin exp((9*ln(etap.min)-ln(etap.max))/8)
cal yetapmax exp((9*ln(etap.max)-ln(etap.min))/8)

cal P (\$rhoc-xminetap)^beta*exp((9*ln(etap.min)+ln(etap.max))/10)

gr 0,,gd.n1-1 pe/gdot rho -err pe?/gdot -sel gdot=gd[#]&rho>=xminetap&rho<=xmaxetap -line

icol rr
for i xminetap*1000 xmaxetap*1000 get i/1000
gr gd.n1 P/(\$rhoc-rr)^beta rr -Dash -rgb 0 0 0

gr gd.n1 -mark 800 5500 -text "\${\scriptstyle (\phi_J-\phi)^{-\beta}}\$"
gr gd.n1+1 -mark 800 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g,~ \alpha=%6.2f}\$" N[0] kd[0] m[0] alpha[0]
gr gd.n1+2 -mark 800 6000 -text "\${\scriptstyle \beta=%3.2f\pm%3.3f}\$" beta betasd

xl (9*xminetap-xmaxetap)/8 (9*xmaxetap-xminetap)/8 lin
yl yetapmin yetapmax log

ctext pe/gdot \$p_e/\dot\gamma\$

latexps ${TP}/${FI}/p_scale/etap-phi/etap-phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig d

cal etap select(pe/gdot,Selb)

cal yetapmin exp((3*ln(etap.min)-ln(etap.max))/2)
cal yetapmax exp((3*ln(etap.max)-ln(etap.min))/2)

cal etap1 etap.min
cal etap2 etap.max

cal E1 select(energy,pe/gdot=etap1&Selb)
cal E1 E1[0]
cal E2 select(energy,pe/gdot=etap2&Selb)
cal E2 E2[0]
cal phi1 select(rho,pe/gdot=etap1&Selb)
cal phi1 phi1[0]
cal phi2 select(rho,pe/gdot=etap2&Selb)
cal phi2 phi2[0]

cal C (((phi_j-phi1)/(E1^w)+(phi2-phi_j)/(E2^w))/((etap1^(-1/beta))/(E1^w)-(etap2^(-1/beta))/(E2^w)))^beta
cal d ((etap2/C)^(-1/beta)+phi2-phi_j)/(E2^w)

cal xeb select(phi_j-rho+d*energy^w,Selb)

gr 0,,gd.n1-1 pe/gdot phi_j-rho+d*energy^w -err pe?/gdot -sel gdot=gd[#]&Selb

icol rrr
for i exp((19*ln(xeb.min)-ln(xeb.max))/18)*1000 exp((19*ln(xeb.max)-ln(xeb.min))/18)*1000 get i/1000
gr gd.n1 C*rrr^(-beta) rrr -Line

gr gd.n1 -mark 800 1000 -text "\${\scriptstyle (\phi_J-\phi+ %6.3f E^{\scriptscriptstyle %6.3f})^{-\beta}}\$" d w
# gr gd.n1+1 -mark 800 500 -text "\${\scriptstyle \chi^2/DOF=%g}\$" chisqb[chisqb.n1-1]
gr gd.n1+2 -mark 800 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g,~ \alpha=%6.2f}\$" N[0] kd[0] m[0] alpha[0]
gr gd.n1+3 -mark 800 6000 -text "\${\scriptstyle \beta=%3.2f,~ \phi_J=%3.4f}\$" beta phi_j

xl exp((9*ln(xeb.min)-ln(xeb.max))/8) exp((9*ln(xeb.max)-ln(xeb.min))/8) log
yl yetapmin yetapmax log

xtext \$\phi_J-\phi_{eff}\$

latexps ${TP}/${FI}/p_scale/etap-phieff_graph/etap-phieff_graph_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig e

cal \$A 0.0004
cal \$c 1.5

# cal Xb (phi-rhoc[rhoc.n1-1])*gdot^h[h.n1-1]
# cal Selb abs(Xb)<\`XMAX&engr>3&gdot<=\`GDOTMAX&gdot>=\`GDOTMIN

for nn 1 10
icol A c Asd csd chisqb
get "lmarqsd(pe,pe?*sdfact,
gdot*\$A*(phi_j-phi+\$c*energy^w):btot^(-beta),
gdot*btot^(-beta),
-gdot*\$A*beta*energy^w*btot^(-beta-1),
Selb)
end

cal xe select(phi_j-rho+c[c.n1-1]*energy^w,Selb)

gr 0,,gd.n1-1 pe/gdot phi_j-rho+c[c.n1-1]*energy^w -err pe?/gdot -sel gdot=gd[#]&Selb

icol rrr
for i exp((19*ln(xe.min)-ln(xe.max))/18)*1000 exp((19*ln(xe.max)-ln(xe.min))/18)*1000 get i/1000
gr gd.n1 A[A.n1-1]*rrr^(-beta) rrr -Line

gr gd.n1 -mark 800 1000 -text "\${\scriptstyle (\phi_J-\phi+ %6.3f E^{\scriptscriptstyle %6.3f})^{-\beta}}\$" c[c.n1-1] w
gr gd.n1+1 -mark 800 500 -text "\${\scriptstyle \chi^2/DOF=%g}\$" chisqb[chisqb.n1-1]
gr gd.n1+2 -mark 800 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g,~ \alpha=%6.2f}\$" N[0] kd[0] m[0] alpha[0]
gr gd.n1+3 -mark 800 6000 -text "\${\scriptstyle \beta=%3.2f,~ \phi_J=%3.4f}\$" beta phi_j

xl exp((9*ln(xe.min)-ln(xe.max))/8) exp((9*ln(xe.max)-ln(xe.min))/8) log
yl yetapmin yetapmax log

xtext \$\phi_J-\phi_{eff}\$

latexps ${TP}/${FI}/p_scale/etap-phieff/etap-phieff_${NU}_KD${K}_M${MA}_EL${EL[$el]}


# fig f

# cal Y exp(\$a0+X*(\$a1+X*(\$a2+X*(\$a3+X*(\$a4+X*\$a5)))))

# gr 0,,gd.n1-1 (pe-gdot^\$q*Y)/pe? (rho-\$rhoc)*gdot^\$h -sel gdot=gd[#]&Sel -err pe?*sdfact/gdot^\$q/Y
# ctext (pe-gdot^\$q*Y)/pe?  \$(p_e-f(\dot\gamma,\phi))/\sigma_{p_e}\$
# ctext (rho-\$rhoc)*gdot^\$h \$(\phi-\phi_J)\dot{\gamma}^h\$

# xl -6 6 lin
# yl - - log
EOF2
			) > ${PL}/p_scale/p_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # scale plot file
			( plo < ${PL}/p_scale/p_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/p_scale/p_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			if [ -d ltot ]; then

			# grc_cr_exp_*_KD*_M*.*

				grc_crexp=() # critical expontents

				grc_crexp1=( `( plo <<EOF2
< "cat ltot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.ltot

cal gdotmax $gdotmax
cal gdotmin $gdotmin
cal xmax 50*$xmax

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal \\$q 0.136
cal \\$a0 -2.82432
cal \\$a1 -4.19327
cal \\$rhoc 0.6429
cal \\$h -0.1
cal \\$a2 5.98509
cal \\$a3 12.8789 
cal \\$a4 -11.9358
cal \\$a5 -24

cal X (phi-\\$rhoc)*gdot^\\$h
cal Sel abs(X)<xmax&engr>3&gdot<=gdotmax&gdot>=gdotmin

for nn 1 10
icol q a0 a1 rhoc h a2 a3 a4 a5 qsd a0sd a1sd rhocsd hsd a2sd a3sd a4sd a5sd chisq
get "lmarqsd(grc,grc?*sdfact,
(gdot^\\$q):gk*exp(\\$a0+\\$a1*((phi-\\$rhoc):rd*(gdot^\\$h):gh):gr+\\$a2*(gr*gr):gr2+\\$a3*(gr*gr2):gr3+\\$a4*(gr2*gr2):gr4+\\$a5*gr2*gr3):atot,
ln(gdot)*gk*atot,
gk*atot,
gk*gr*atot,
gk*gh*(-1)*(\\$a1+\\$a2*2*gr+\\$a3*3*gr2+\\$a4*4*gr3+\\$a5*5*gr4):tot12345*atot,
gk*ln(gdot)*gh*rd*tot12345*atot,
gk*gr2*atot,
gk*gr3*atot,
gk*gr4*atot,
gk*gr2*gr3*atot,
Sel)
end

cal beta (q[q.n1-1]-1)/h[h.n1-1]
cal betasd beta*sqrt((qsd[qsd.n1-1]/q[q.n1-1])^2+(hsd[hsd.n1-1]/h[h.n1-1])^2)

list rhoc[rhoc.n1-1] rhocsd[rhocsd.n1-1] beta betasd q[q.n1-1] qsd[qsd.n1-1] h[h.n1-1] hsd[hsd.n1-1] chisq[chisq.n1-1]
exit
EOF2
				) | grep -v Plo | grep -v '...>'` ) # critical exponents, inferred from the Levenbergâ€“Marquardt least squared curve fitting method
				if [[ "${#grc_crexp1[@]}" = "${#grc_col1[@]}" ]]; then # no errors in the measurement
					grc_crexp+=( ${grc_crexp1[@]} )
				else
					grc_crexp+=( $(for i in $(seq 1 ${#grc_col1[@]}); do echo 0; done) )
				fi

				grc_cr_exp+=( [${EL[$el]}]="${grc_crexp[@]}" )
				
				values="${NU} ${K:1:1}.${K:2:2}${exponents[${K:0:1}]} ${MA:1:1}.${MA:2:2}${exponents[${MA:0:1}]} ${EL[$el]:0:1}.${EL[$el]:1:2} ${grc_crexp[@]} " # values
				values=( $values )
				if [[ "${#values[@]}" = "${#grc_col[@]}" ]]; then # no error in the determination of the critical exponents (this should always be true because of the previous tests)
					echo ${values[@]} >> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.out # writes in plo parsed file
					echo ${values[@]} | sed s/' '/','/g >> ${CR}/grc_cr_exp_${NU}_KD${K}_M${MA}.csv # writes in csv parsed data
				fi

				# grc_scale_*_KD*_M*_EL*.plo

				( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.ltot
getenv GDOTMAX $gdotmax
getenv GDOTMIN $gdotmin
getenv XMAX 50*$xmax

icol gd
`for gd in ${GD[@]}; do echo $gd; done`

cal sdfact sqrt((engr-1)/(engr-3))
cal phi rho

cal \$q 0.136
cal \$a0 -2.82432
cal \$a1 -4.19327
cal \$rhoc 0.6429
cal \$h -0.1
cal \$a2 5.98509
cal \$a3 12.8789 
cal \$a4 -11.9358
cal \$a5 -24

cal X (phi-\$rhoc)*gdot^\$h
cal Sel abs(X)<\`XMAX&engr>3&gdot<=\`GDOTMAX&gdot>=\`GDOTMIN

for nn 1 10
icol q a0 a1 rhoc h a2 a3 a4 a5 qsd a0sd a1sd rhocsd hsd a2sd a3sd a4sd a5sd chisq
get "lmarqsd(grc,grc?*sdfact,
(gdot^\$q):gk*exp(\$a0+\$a1*((phi-\$rhoc):rd*(gdot^\$h):gh):gr+\$a2*(gr*gr):gr2+\$a3*(gr*gr2):gr3+\$a4*(gr2*gr2):gr4+\$a5*gr2*gr3):atot,
ln(gdot)*gk*atot,
gk*atot,
gk*gr*atot,
gk*gh*(-1)*(\$a1+\$a2*2*gr+\$a3*3*gr2+\$a4*4*gr3+\$a5*5*gr4):tot12345*atot,
gk*ln(gdot)*gh*rd*tot12345*atot,
gk*gr2*atot,
gk*gr3*atot,
gk*gr4*atot,
gk*gr2*gr3*atot,
Sel)
end

cal beta (q[q.n1-1]-1)/h[h.n1-1]
cal betasd beta*sqrt((qsd[qsd.n1-1]/q[q.n1-1])^2+(hsd[hsd.n1-1]/h[h.n1-1])^2)

cal xminetap \$rhoc-0.05
cal xmaxetap \$rhoc+0.02
cal Selb rho>=xminetap&rho<=xmaxetap&grc>0

cal w -0.5*h[h.n1-1]/q[q.n1-1]
cal phic rhoc[rhoc.n1-1]


fig a

gr 0,,gd.n1-1 grc rho -err grc? -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 600+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr gd.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr gd.n1+3 -mark 500 5000 -text "\${\scriptstyle \alpha=%6.2f}\$" alpha[0]

xl rho.min-0.1 - lin
yl - - lin

ctext grc \$g^{RC}\$
ctext rho \$\phi\$

latexps ${TP}/${FI}/grc_scale/grc-phi/grc-phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig b

cal X (rho-\$rhoc)*gdot^\$h
cal Sel abs(X)<\`XMAX&engr>3&gdot<=\`GDOTMAX&gdot>=\`GDOTMIN
cal grcq select(grc/gdot^\$q,Sel)

cal ygrcqmin exp(2*ln(grcq.min)-ln(grcq.max))
cal ygrcqmax exp(2*ln(grcq.max)-ln(grcq.min))

gr 0,,gd.n1-1 grc/gdot^\$q X -err sqrt(grc?^2+(grc*ln(gdot)*qsd[qsd.n1-1])^2)/gdot^\$q -sel gdot=gd[#]&Sel

icol x
for i -110*\`XMAX 110*\`XMAX get i/100
gr gd.n1 exp(\$a0+x*(\$a1+x*(\$a2+x*(\$a3+x*(\$a4+x*\$a5))))) x -Line

gr gd.n1 -mark 800 800 -text "\${\scriptscriptstyle f(X)=\exp\left(\sum_{i=0}^{5}a_iX^i\right)}\$"
gr gd.n1+1 -mark 6000 800 -text "\${\scriptstyle \phi_{\scriptscriptstyle C}=%6.4f\pm%6.5f}\$" rhoc[rhoc.n1-1] rhocsd[rhocsd.n1-1]
gr gd.n1+2 -mark 800 5800 -text "\${\scriptstyle q_{g^{RC}}=%5.3f\pm%5.4f,~ h_{g^{RC}}=%5.3f\pm%5.4f}\$" q[q.n1-1] qsd[qsd.n1-1] h[h.n1-1] hsd[hsd.n1-1]
gr gd.n1+3 -mark 800 6300 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g,~ \alpha=%6.2f}\$" N[0] kd[0] m[0] alpha[0]
gr gd.n1+4 -mark 800 5300 -text "\${\scriptstyle \chi^2/DOF=%3.2f}\$" chisq[chisq.n1-1]

xl -1.25*\`XMAX 1.25*\`XMAX lin
yl ygrcqmin ygrcqmax log

ctext grc/gdot^\$q \$g^{RC}/\dot\gamma^{q_{g^{RC}}}\$
ctext X \$(\phi-\phi_C)\dot\gamma^{h_{g^{RC}}}\$

latexps ${TP}/${FI}/grc_scale/grc-dphi-scale/grc-dphi-scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
				) > ${PL}/grc_scale/grc_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # scale plot file
				( plo < ${PL}/grc_scale/grc_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
				echo d >> ${PL}/grc_scale/grc_scale_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			fi

			# rheo_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

icol gd
`for gd in ${GD[@]}; do echo $gd; done`


fig a

gr 0,,gd.n1-1 pe/gdot rho -err pe?/gdot -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 600+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr gd.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr gd.n1+3 -mark 500 5000 -text "\${\scriptstyle \alpha=%6.2f}\$" alpha[0]

xl rho.min-0.1 - lin
yl - - log

xtext \$\phi\$
ytext \$\eta_p\$

latexps ${TP}/${FI}/rheo/etap/etap_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig b

gr 0,,gd.n1-1 pe/gdot^2 rho -err pe?/gdot^2 -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 600+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr gd.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr gd.n1+3 -mark 500 5000 -text "\${\scriptstyle \alpha=%6.2f}\$" alpha[0]

xl rho.min-0.1 - lin
yl - - log

xtext \$\phi\$
ytext \$B_p\$

latexps ${TP}/${FI}/rheo/bp/bp_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
			) > ${PL}/rheo/rheo_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # scale plot file
			( plo < ${PL}/rheo/rheo_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/rheo/rheo_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			# ori_phi_*_KD*_M*_GD*_EL*.plo

			for gd in $(seq 0 $((${#GD[@]}-1))); do # per shear rate

				( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

cal gd ${GD[$gd]}

cal xrho select(rho,gdot=gd)

cal ori0gd select(ori0,gdot=gd)
cal ori1gd select(ori1,gdot=gd)
cal ori2gd select(ori2,gdot=gd)

icol yorimin
get ori0gd.min
get ori1gd.min
get ori2gd.min
cal yorimin yorimin.min

icol yorimax
get ori0gd.max
get ori1gd.max
get ori2gd.max
cal yorimax yorimax.max


fig a

gr 0,,2 ori# rho -line -sel gdot=gd
gr 0,,2 -mark 500 6500-#*500 -text "\${\scriptstyle O_%1.0f}\$" #

gr 3 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr 4 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g,~ \alpha=%6.2f}\$" m[0] gd alpha[0]

xl (19*xrho.min-xrho.max)/18 (19*xrho.max-xrho.min)/18 lin
yl (3*yorimin-yorimax)/2 (3*yorimax-yorimin)/2 lin

xtext \$\phi\$
ytext \$O_i\$

latexps ${TP}/${FI}/ori/ori_phi/ori_phi_${NU}_KD${K}_M${MA}_GD${GD_[$gd]}_EL${EL[$el]}
EOF2
				) > ${PL}/ori_gd/ori_phi_${NU}_KD${K}_M${MA}_GD${GD_[$gd]}_EL${EL[$el]}.plo # orientation plot file
				( plo < ${PL}/ori_gd/ori_phi_${NU}_KD${K}_M${MA}_GD${GD_[$gd]}_EL${EL[$el]}.plo ) &> /dev/null
				echo d >> ${PL}/ori_gd/ori_phi_${NU}_KD${K}_M${MA}_GD${GD_[$gd]}_EL${EL[$el]}.plo

			done

			# omegagd_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

icol gd
`for gd in ${GD[@]}; do echo $gd; done`

cal c ${p_crexp[${p_hashcol[cg]}]}
cal w -0.5*${p_crexp[${p_hashcol[q]}]}/${p_crexp[${p_hashcol[h]}]}


fig a

cal omegagd omega/gdot

gr 0,,gd.n1-1 omega/gdot rho -err omega?/gdot -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle \alpha=%1.2f,~ m=%g}\$" alpha[0] m[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*omegagd.min-omegagd.max)/18 (19*omegagd.max-omegagd.min)/18 lin

xtext \$\phi\$
ytext \$\omega/\dot{\gamma}\$

latexps ${TP}/${FI}/omegagd/omegagd_phi_gd/omegagd_phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}


fig b

cal xphieff rho-c*energy^w

gr 0,,gd.n1-1 omega/gdot rho-c*energy^w -err omega?/gdot -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle \alpha=%1.2f,~ m=%g}\$" alpha[0] m[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xphieff.min-xphieff.max)/2 (3*xphieff.max-xphieff.min)/2 lin
yl (19*omegagd.min-omegagd.max)/18 (19*omegagd.max-omegagd.min)/18 lin

xtext \$\phi_{eff}\$
ytext \$\omega/\dot{\gamma}\$

latexps ${TP}/${FI}/omegagd/omegagd_phieff_gd/omegagd_phieff_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
			) > ${PL}/omegagd_gd/omegagd_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # rotation velocity over shear rate plot file
			( plo < ${PL}/omegagd_gd/omegagd_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/omegagd_gd/omegagd_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			# vijrc_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.ltot

icol gd
`for gd in ${GD[@]}; do echo $gd; done`

cal vijrc sqrt(rvij2/cvij2)


fig a

gr 0,,gd.n1-1 vijrc rho -err 0 -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle \alpha=%1.2f,~ m=%g}\$" alpha[0] m[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*vijrc.min-vijrc.max)/18 (19*vijrc.max-vijrc.min)/18 lin

xtext \$\phi\$
ytext \$v^R_{ij}/v^C_{ij}\$

latexps ${TP}/${FI}/vijrc_phi_gd/vijrc_phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
			) > ${PL}/vijrc_gd/vijrc_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # rotational and centre of mass velocity ratio at contact plot file
			( plo < ${PL}/vijrc_gd/vijrc_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/vijrc_gd/vijrc_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			# S2_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.ltot

icol gd
`for gd in ${GD[@]}; do echo $gd; done`


fig a

gr 0,,gd.n1-1 nemS2 rho -err 0 -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle \alpha=%1.2f,~ m=%g}\$" alpha[0] m[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*nemS2.min-nemS2.max)/18 (19*nemS2.max-nemS2.min)/18 lin

xtext \$\phi\$
ytext \$S_2\$

latexps ${TP}/${FI}/S2_phi_gd/S2_phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
			) > ${PL}/S2_gd/S2_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # biggest eigenvalue of the order tensor plot file
			( plo < ${PL}/S2_gd/S2_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/S2_gd/S2_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

			# omegav_*_KD*_M*_EL*.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_KD${K}_M${MA}_EL${EL[$el]}_*.tot

icol gd
`for gd in ${GD[@]}; do echo $gd; done`

cal yomegav select(omega/vr,1=1)


fig a

gr 0,,gd.n1-1 omega/vr rho -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \dot\gamma=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]
gr gd.n1+1 -mark 500 6000 -text "\${\scriptstyle \alpha=%1.2f}\$" alpha[0]

xl ((13/4)*rho.min-rho.max)*(4/9) ((11/2)*rho.max-rho.min)*(2/9) lin
yl (4*yomegav.min-yomegav.max)/3 (4*yomegav.max-yomegav.min)/3 lin

xtext \$\phi\$
ytext \$\omega/v\$

latexps ${TP}/${FI}/omegav/omegav_phi_gd/omegav_phi_${NU}_KD${K}_M${MA}_EL${EL[$el]}
EOF2
			) > ${PL}/omegav_gd/omegav_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo # ratio of rotational and translational velocities plot file
			( plo < ${PL}/omegav_gd/omegav_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo ) &> /dev/null
			echo d >> ${PL}/omegav_gd/omegav_${NU}_KD${K}_M${MA}_EL${EL[$el]}.plo

		fi

	done

	# p_cr_exp_*_KD*_M*.plo

	( cat <<EOF2
< ${TP}/${CR}/p_cr_exp_${NU}_KD${K}_M${MA}.out

cal xalpha select(alpha,chisq<4)
cal ybeta select(beta,chisq<4)
cal yphij select(phij,chisq<4)

icol el
`for el in ${_EL[@]}; do echo ${el:0:1}.${el:1:2}; done`


fig a

gr 0 beta alpha -err beta? -line -sel chisq<4

gr 1 -mark 6000 500 -text "\${\scriptstyle N=%g,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]

xtext \$\alpha\$
ytext \$\beta\$

xl (19*xalpha.min-xalpha.max)/18 (19*xalpha.max-xalpha.min)/18 lin
yl (19*ybeta.min-ybeta.max)/18 (19*ybeta.max-ybeta.min)/18 lin

latexps ${TP}/${FI}/p_cr_exp/beta/beta_alpha_${NU}_KD${K}_M${MA}


fig b

gr 0 phij alpha -err phij? -line -sel chisq<4

gr 1 -mark 6000 500 -text "\${\scriptstyle N=%g,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]

xtext \$\alpha\$
ytext \$\phi_J\$

xl (19*xalpha.min-xalpha.max)/18 (19*xalpha.max-xalpha.min)/18 lin
yl (19*yphij.min-yphij.max)/18 (19*yphij.max-yphij.min)/18 lin

latexps ${TP}/${FI}/p_cr_exp/phij/phij_alpha_${NU}_KD${K}_M${MA}


fig c

gr 0,,el.n1-1 beta gdmax 
EOF2
	) > ${PL}/p_cr_exp/p_cr_exp_${NU}_KD${K}_M${MA}.plo # critical exponents plot file
	( plo < ${PL}/p_cr_exp/p_cr_exp_${NU}_KD${K}_M${MA}.plo ) &> /dev/null
	echo d >> ${PL}/p_cr_exp/p_cr_exp_${NU}_KD${K}_M${MA}.plo

	# p_cr_exp_gdmax_*_KD*_M*.plo

	( cat <<EOF2
< ${TP}/${CR}/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.out

icol el
`for el in ${_EL[@]}; do echo ${el:0:1}.${el:1:2}; done`


fig a

gr 0,,el.n1-1 beta gdmax -err beta? -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%g,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]

xtext \$\dot{\gamma}_{max}\$
ytext \$\beta\$

xl exp((4*ln(gdmax.min)-ln(gdmax.max))/3) exp((4*ln(gdmax.max)-ln(gdmax.min))/3) log
yl (4*beta.min-beta.max)/3 (4*beta.max-beta.min)/3 lin

latexps ${TP}/${FI}/p_cr_exp_gdmax/beta/beta_gdmax_${NU}_KD${K}_M${MA}


fig b

gr 0,,el.n1-1 phij gdmax -err phij? -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%g,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]

xtext \$\dot{\gamma}_{max}\$
ytext \$\phi_J\$

xl exp((4*ln(gdmax.min)-ln(gdmax.max))/3) exp((4*ln(gdmax.max)-ln(gdmax.min))/3) log
yl (4*phij.min-phij.max)/3 (4*phij.max-phij.min)/3 lin

latexps ${TP}/${FI}/p_cr_exp_gdmax/phij/phij_gdmax_${NU}_KD${K}_M${MA}


fig c

gr 0,,el.n1-1 chisq gdmax -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%g,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]

xtext \$\dot{\gamma}_{max}\$
ytext \$\chi^2/DOF\$

xl exp((4*ln(gdmax.min)-ln(gdmax.max))/3) exp((4*ln(gdmax.max)-ln(gdmax.min))/3) log
yl (4*chisq.min-chisq.max)/3 (4*chisq.max-chisq.min)/3 lin

latexps ${TP}/${FI}/p_cr_exp_gdmax/chisq/chisq_gdmax_${NU}_KD${K}_M${MA}
EOF2
	) > ${PL}/p_cr_exp_gdmax/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.plo # critical exponents according to maximum shear rates plot file
	( plo < ${PL}/p_cr_exp_gdmax/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.plo ) &> /dev/null
	echo d >> ${PL}/p_cr_exp_gdmax/p_cr_exp_gdmax_${NU}_KD${K}_M${MA}.plo

	# per shear rate

	printf "\n"

	unset GD; GD=($(for file in ${files[@]}; do echo ${file:${args[GD]}:4}; done | sort)) # sorted shear rates (with Olsson's notation)
	unset GD_; GD_=($(for gd in ${GD[@]}; do echo ${gd:1:1}.${gd:2:2}${exponents[${gd:0:1}]}; done)) # array of the shear rates
	unset _GD; _GD=() # shear rates which have already been treated

	> ${ZR}/z_${NU}_KD${K}_M${MA}.out # plo data
	> ${ZR}/z_${NU}_KD${K}_M${MA}.csv # csv data
	if [ -d ltot ]; then
		z_col=( N rho gdot kd m alpha zr z zsd engr ) # variables to be measured for contact output files
		foo="icol $(for el in ${z_col[@]}; do echo $el | ( [[ ${el: -2} == sd ]] && sed s/$el/?/ || cat); done)" # variables to be measured for contact output files parsed for plo
	else
		z_col=( N rho gdot kd m alpha z zsd engr ) # variables to be measured for contact output files
		foo="icol $(for el in ${z_col[@]}; do echo $el | ( [[ ${el: -2} == sd ]] && sed s/$el/?/ || cat); done)" # variables to be measured for contact output files parsed for plo
	fi
	echo $foo >> ${ZR}/z_${NU}_KD${K}_M${MA}.out
	echo ${z_col[@]} | sed s/' '/','/g >> ${ZR}/z_${NU}_KD${K}_M${MA}.csv

	> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.out # plo data
	> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.csv # csv data
	foo="gdot alpha omegav_phiJ"
	echo "icol $foo" >> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.out
	echo $foo | sed s/' '/','/g >> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.csv

	p_col=( $(for el in ${p_col[@]:${#p_col0[@]}}; do echo $el | ( [[ ${el: -2} == sd ]] && sed s/$el/?/ || cat); done) ) # columns of critical exponents associated to pressure to add to output data files

	for gd in $(seq 0 $((${#GD[@]}-1))); do

		if [[ ! "${_GD[@]}" =~ "${GD[$gd]}" ]]; then # if the shear rate ${GD[$gd]} has not been treated yet

			_GD+=(${GD[$gd]}) # we add the current shear rate to the already treated array

			files_GD=($(for file in ${files[@]}; do echo $file | grep GD${GD[$gd]}; done)) # files to treat for the current value of the shear rate
			echo "Reading from ${#files_GD[@]} files with gdot=${GD_[$gd]}."

			unset EL_; EL_=() # arrays of the aspect ratios (without separator)
			for file in ${files_GD[@]}; do

				if [[ ! "${EL_[@]}" =~ "${file:${args[EL]}:3}" ]]; then
					EL_+=(${file:${args[EL]}:3})
				fi

				# creating .meas files with critical exponents in the .tot directory
				foo="icol ${p_col[@]}" # item to add to .meas files
				p_crexp=( ${p_cr_exp[${file:${args[EL]}:3}]} )
				echo $foo > tot/${file}.meas
				if [[ "${#p_crexp[@]}" = "${#p_col[@]}" ]]; then # no errors in the critical exponents
					echo "${p_crexp[@]}" >> tot/${file}.meas
				else
					echo $(for i in $(seq ${#p_col[@]}); do echo 0; done) >> tot/${file}.meas
				fi

				# orientation related variables
				for or in j $(seq 0 2); do
					foo="icol ori${or}m ori${or}sd" # item to look for in .tot files
					if ! grep -Fq "$foo" tot/${file}.tot; then
						mean_stdev=( `( plo <<EOF2
< "cat ttime/${file}.ttime

< "_plo_mean_stdev ori${or}
list mean stdev
EOF2
						) | grep -v Plo` ) # mean and standard deviation of orientation-related variables
						echo "$foo" >> tot/${file}.tot
						echo ${mean_stdev[@]} >> tot/${file}.tot
					fi
				done

				# contact related variables
				if [ -d ltot ]; then
					values=( ` ( plo <<EOF2
< "cat ltot/${file}.ltot
list N rho gdot kd m alpha zr
EOF2
					) | grep -v Plo ` ) # number of contacts without rattlers
					values+=( ` ( plo <<EOF2
< "cat tot/${file}.tot
list z z? engr
EOF2
					) | grep -v Plo ` )
					if [[ ( "${values[-3]}" != "-" ) || ( "${values[-4]}" != "-" ) ]] && [[ "${#values[@]}" = "${#z_col[@]}" ]]; then # the number of contacts is defined
						echo ${values[@]} >> ${ZR}/z_${NU}_KD${K}_M${MA}.out
						echo ${values[@]} | sed s/' '/','/g >> ${ZR}/z_${NU}_KD${K}_M${MA}.csv
					fi
				else
					values=( ` ( plo <<EOF2
< "cat tot/${file}.tot
list N rho gdot kd m alpha z z? engr
EOF2
					) | grep -v Plo ` ) # number of contacts (with rattlers)
					if [[ "${values[-3]}" != "-" ]] && [[ "${#values[@]}" = "${#z_col[@]}" ]]; then # the number of contacts is defined
						echo ${values[@]} >> ${ZR}/z_${NU}_KD${K}_M${MA}.out
						echo ${values[@]} | sed s/' '/','/g >> ${ZR}/z_${NU}_KD${K}_M${MA}.csv
					fi
				fi

			done
			EL_=($(for el in ${EL_[@]}; do echo $el; done | sort)) # sorted aspect ratios
			unset EL; EL=($(for el in ${EL_[@]}; do echo ${el:0:1}.${el:1:2}; done)) # arrays of the aspect ratios

			# omegav_phiJ_${NU}_KD${K}_M${MA}.*

			for el in $(seq 0 $((${#EL[@]}-1))); do
				if ls tot/1024_*_GD${GD[$gd]}_KD${K}_M${MA}_EL${EL_[$el]}_* &> /dev/null; then # if there are .tot files corresponding to these parameters
					omegav=( `( plo <<EOF2
< "cat tot/1024_*_GD${GD[$gd]}_KD${K}_M${MA}_EL${EL_[$el]}_*
list select(omega/vr,rho>phij)
EOF2
					) | grep -v Plo` ) # ratio of rotational and translational velocities values above phi_J
					omegav_mean="`python <<EOF2
omegav=[$(echo ${omegav[@]} | sed s/' '/','/g)]
print( sum(omegav)/len(omegav) )
EOF2
					`"
				else
					omegav_mean="-"
				fi

				values=( ${GD_[$gd]} ${EL[$el]} $omegav_mean ) # mean of the ratio of rotational and translational velocities values above phi_J
				echo ${values[@]} >> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.out # plo data
				echo ${values[@]} | sed s/' '/','/g >> ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.csv # csv data
			done

			# orij_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

`_plo_peak orij rho el alpha`


fig a

cal yorij select(orij,alpha>1)

gr 0,,el.n1-1 orij rho -err orijsd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yy
for i 1000*(19*yorij.min-yorij.max)/18 1000*(19*yorij.max-yorij.min)/18 get i/1000
gr el.n1 yy peak -Dash
gr el.n1 -mark 7300 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+2 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*yorij.min-yorij.max)/18 (19*yorij.max-yorij.min)/18 lin

xtext \$\phi\$
ytext \$\mathcal{C}_{ij}\$

latexps ${TP}/${FI}/orij/prolate/orij_phi/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig b

cal orijal select(orij/alpha,alpha>1)

gr 0,,el.n1-1 orij/alpha rho -err orijsd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yyy
for i 1000*(19*orijal.min-orijal.max)/18 1000*(19*orijal.max-orijal.min)/18 get i/1000
gr el.n1 yyy peak -Dash
gr el.n1 -mark 7300 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+2 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*orijal.min-orijal.max)/18 (19*orijal.max-orijal.min)/18 lin

xtext \$\phi\$
ytext \$\mathcal{C}_{ij}/\alpha\$

latexps ${TP}/${FI}/orij/prolate/orijal_phi/orijal_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig c

cal xr rho-c*energy^(-0.5*h/q)

gr 0,,el.n1-1 orij rho-c*energy^(-0.5*h/q) -err orijsd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 6500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 6500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xr.min-xr.max)/2 (3*xr.max-xr.min)/2 lin
yl (19*yorij.min-yorij.max)/18 (19*yorij.max-yorij.min)/18 lin

xtext \$\phi_{eff}\$
ytext \$\mathcal{C}_{ij}\$

latexps ${TP}/${FI}/orij/prolate/orij_phieff/orij_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig d

gr 0,,el.n1-1 orij/alpha rho-c*energy^(-0.5*h/q) -err orijsd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xr.min-xr.max)/2 (3*xr.max-xr.min)/2 lin
yl (19*orijal.min-orijal.max)/18 (19*orijal.max-orijal.min)/18 lin

xtext \$\phi_{eff}\$
ytext \$\mathcal{C}_{ij}/\alpha\$

latexps ${TP}/${FI}/orij/prolate/orijal_phieff/orijal_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/orij/prolate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # orientation correlation plot file
			( plo < ${PL}/orij/prolate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/orij/prolate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# orij_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`


fig a

cal yorij select(orij,alpha<1)

gr 0,,el.n1-1 orij rho -err orijsd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 6500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 6500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*yorij.min-yorij.max)/18 (19*yorij.max-yorij.min)/18 lin

xtext \$\phi\$
ytext \$\mathcal{C}_{ij}\$

latexps ${TP}/${FI}/orij/oblate/orij_phi/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig b

cal orijal select(orij/alpha,alpha<1)

gr 0,,el.n1-1 orij/alpha rho -err orijsd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*orijal.min-orijal.max)/18 (19*orijal.max-orijal.min)/18 lin

xtext \$\phi\$
ytext \$\mathcal{C}_{ij}/\alpha\$

latexps ${TP}/${FI}/orij/oblate/orijal_phi/orijal_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig c

cal xr rho-c*energy^(-0.5*h/q)

gr 0,,el.n1-1 orij rho-c*energy^(-0.5*h/q) -err orijsd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 6500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 6500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xr.min-xr.max)/2 (3*xr.max-xr.min)/2 lin
yl (19*yorij.min-yorij.max)/18 (19*yorij.max-yorij.min)/18 lin

xtext \$\phi_{eff}\$
ytext \$\mathcal{C}_{ij}\$

latexps ${TP}/${FI}/orij/oblate/orij_phieff/orij_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig d

gr 0,,el.n1-1 orij/alpha rho-c*energy^(-0.5*h/q) -err orijsd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xr.min-xr.max)/2 (3*xr.max-xr.min)/2 lin
yl (19*orijal.min-orijal.max)/18 (19*orijal.max-orijal.min)/18 lin

xtext \$\phi_{eff}\$
ytext \$\mathcal{C}_{ij}/\alpha\$

latexps ${TP}/${FI}/orij/oblate/orijal_phieff/orijal_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/orij/oblate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # orientation correlation plot file
			( plo < ${PL}/orij/oblate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/orij/oblate/orij_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# omegagd_phi_*_KD*_M*_GD*.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.tot

icol el
`for el in ${EL[@]}; do echo $el; done`


fig a

cal omegagd omega/gdot

gr 0,,el.n1-1 omega/gdot rho -err omega?/gdot -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*omegagd.min-omegagd.max)/18 (19*omegagd.max-omegagd.min)/18 lin

xtext \$\phi\$
ytext \$\omega/\dot{\gamma}\$

latexps ${TP}/${FI}/omegagd/omegagd_phi_el/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}
EOF2
			) > ${PL}/omegagd_el/omegagd_phi/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo # rotation velocity over shear rate plot file
			( plo < ${PL}/omegagd_el/omegagd_phi/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo ) &> /dev/null
			echo d >> ${PL}/omegagd_el/omegagd_phi/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo

			# omegagd_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.tot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

`_plo_peak omega/gdot rho el alpha "rho<0.6&gdot=${GD_[$gd]}"`


fig a

cal omegagd select(omega/gdot,alpha>1)

gr 0,,el.n1-1 omega/gdot rho -err omega?/gdot -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yy
for i 100*(19*omegagd.min-omegagd.max)/18 100*(19*omegagd.max-omegagd.min)/18 get i/100
gr el.n1 yy peak -Dash
gr el.n1 -mark 7800 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+2 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*omegagd.min-omegagd.max)/18 (19*omegagd.max-omegagd.min)/18 lin

xtext \$\phi\$
ytext \$\omega/\dot{\gamma}\$

latexps ${TP}/${FI}/omegagd/prolate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/omegagd_el/prolate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # rotation velocity over shear rate plot file
			( plo < ${PL}/omegagd_el/prolate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/omegagd_el/prolate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# omegagd_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.tot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`


fig a

cal omegagd select(omega/gdot,alpha<1)

gr 0,,el.n1-1 omega/gdot rho -err omega?/gdot -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (19*omegagd.min-omegagd.max)/18 (19*omegagd.max-omegagd.min)/18 lin

xtext \$\phi\$
ytext \$\omega/\dot{\gamma}\$

latexps ${TP}/${FI}/omegagd/oblate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/omegagd_el/oblate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # rotation velocity over shear rate plot file
			( plo < ${PL}/omegagd_el/oblate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/omegagd_el/oblate/omegagd_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# zr_phi_*_KD*_M*_GD*.plo

			if [ -d ltot ]; then

				( cat <<EOF2
< ${TP}/${ZR}/z_${NU}_KD${K}_M${MA}.out

cal gd ${GD_[$gd]}

icol el
`for el in ${EL[@]}; do echo $el; done`

cal xrho select(rho,gdot=gd&zr>0)
cal yzr select(zr,gdot=gd&zr>0)

gr 0,,el.n1-1 zr rho -err z? -line -sel alpha=el[#]&gdot=gd
gr 0,,el.n1-1 -mark 8000 500+#*600 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gd m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yzr.min-yzr.max)/18 (19*yzr.max-yzr.min)/18 lin

xtext \$\phi\$
ytext \$z_r\$

latexps ${TP}/${FI}/zr_phi/zr_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}
EOF2
				) > ${PL}/zr_phi/zr_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo # contact number plot file
				( plo < ${PL}/zr_phi/zr_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo ) &> /dev/null
				echo d >> ${PL}/zr_phi/zr_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo

			fi

			# z_phi_*_KD*_M*_GD*.plo

			( cat <<EOF2
< ${TP}/${ZR}/z_${NU}_KD${K}_M${MA}.out

cal gd ${GD_[$gd]}

icol el
`for el in ${EL[@]}; do echo $el; done`

cal xrho select(rho,gdot=gd&z>0)
cal yz select(z,gdot=gd&z>0)

gr 0,,el.n1-1 z rho -err z? -line -sel alpha=el[#]&gdot=gd
gr 0,,el.n1-1 -mark 8000 500+#*600 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gd m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yz.min-yz.max)/18 (19*yz.max-yz.min)/18 lin

xtext \$\phi\$
ytext \$z\$

latexps ${TP}/${FI}/z/z_phi/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}
EOF2
			) > ${PL}/z/z_phi/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo # contact number plot file
			( plo < ${PL}/z/z_phi/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo ) &> /dev/null
			echo d >> ${PL}/z/z_phi/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}.plo

			# z_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< ${TP}/${ZR}/z_${NU}_KD${K}_M${MA}.out

cal gd ${GD_[$gd]}

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

`_plo_peak_der z rho el alpha "rho<0.6&gdot=gd"`


cal xrho select(rho,gdot=gd&z>0)
cal yz select(z,gdot=gd&z>0)

gr 0,,el.n1-1 z rho -err z? -line -sel alpha=el[#]&gdot=gd
gr 0,,el.n1-1 -mark 8000 500+#*600 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yy
for i 100*(19*yz.min-yz.max)/18 100*(19*yz.max-yz.min)/18 get i/100
gr el.n1 yy peak -Dash
gr el.n1 -mark 7800 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gd m[0]
gr el.n1+2 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yz.min-yz.max)/18 (19*yz.max-yz.min)/18 lin

xtext \$\phi\$
ytext \$z\$

latexps ${TP}/${FI}/z/prolate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/z/prolate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # contact number plot file
			( plo < ${PL}/z/prolate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/z/prolate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# z_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< ${TP}/${ZR}/z_${NU}_KD${K}_M${MA}.out

cal gd ${GD_[$gd]}

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`

cal xrho select(rho,gdot=gd&z>0)
cal yz select(z,gdot=gd&z>0)

gr 0,,el.n1-1 z rho -err z? -line -sel alpha=el[#]&gdot=gd
gr 0,,el.n1-1 -mark 8000 500+#*600 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 500 6000 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gd m[0]
gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yz.min-yz.max)/18 (19*yz.max-yz.min)/18 lin

xtext \$\phi\$
ytext \$z\$

latexps ${TP}/${FI}/z/oblate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/z/oblate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # contact number plot file
			( plo < ${PL}/z/oblate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/z/oblate/z_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# ori*_phi_*_KD*_M*_GD*_prolate.plo

			for or in $(seq 0 2); do # per direction

				( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

cal ori${or}sgn $(((-1)**$((0!=$or))))*ori${or}

`_plo_peak ori${or}sgn rho el alpha`


fig a

cal yori${or} select(ori${or},alpha>1)

gr 0,,el.n1-1 ori${or} rho -err ori${or}sd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yy
for i 1000*(5*yori${or}.min-yori${or}.max)/4 1000*(5*yori${or}.max-yori${or}.min)/4 get i/1000
gr el.n1 yy peak -Dash
gr el.n1 -mark 7300 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+2 -mark 500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (5*yori${or}.min-yori${or}.max)/4 (5*yori${or}.max-yori${or}.min)/4 lin

xtext \$\phi\$
ytext \$O_${or}\$

latexps ${TP}/${FI}/ori/prolate/ori${or}_phi/ori${or}_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig b

cal orial select(ori${or}/alpha,alpha>1)

gr 0,,el.n1-1 ori${or}/alpha rho -err ori${or}sd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

icol yyy
for i 1000*(5*orial.min-orial.max)/4 1000*(5*orial.max-orial.min)/4 get i/1000
gr el.n1 yyy peak -Dash
gr el.n1 -mark 7300 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+2 -mark 500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (5*orial.min-orial.max)/4 (5*orial.max-orial.min)/4 lin

xtext \$\phi\$
ytext \$O_${or}/\alpha\$


latexps ${TP}/${FI}/ori/prolate/ori${or}al_phi/ori${or}al_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig c

cal xrho rho-cg*energy^(-0.5*h/q)

gr 0,,el.n1-1 ori${or} rho-cg*energy^(-0.5*h/q) -err ori${or}sd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (5*yori${or}.min-yori${or}.max)/4 (5*yori${or}.max-yori${or}.min)/4 lin

xtext \$\phi_{eff}\$
ytext \$O_${or}\$

latexps ${TP}/${FI}/ori/prolate/ori${or}_phieff/ori${or}_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate


fig d

gr 0,,el.n1-1 ori${or}/alpha rho-cg*energy^(-0.5*h/q) -err ori${or}sd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (5*orial.min-orial.max)/4 (5*orial.max-orial.min)/4 lin

xtext \$\phi_{eff}\$
ytext \$O_${or}/\alpha\$


latexps ${TP}/${FI}/ori/prolate/ori${or}al_phieff/ori${or}al_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
				) > ${PL}/ori_el/prolate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # orientation plot file
				( plo < ${PL}/ori_el/prolate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
				echo d >> ${PL}/ori_el/prolate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			done

			# ori*_phi_*_KD*_M*_GD*_oblate.plo

			for or in $(seq 0 2); do # per direction

				( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`


fig a

cal yori${or} select(ori${or},alpha<1)

gr 0,,el.n1-1 ori${or} rho -err ori${or}sd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (5*yori${or}.min-yori${or}.max)/4 (5*yori${or}.max-yori${or}.min)/4 lin

xtext \$\phi\$
ytext \$O_${or}\$

latexps ${TP}/${FI}/ori/oblate/ori${or}_phi/ori${or}_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig b

cal orial select(ori${or}/alpha,alpha<1)

gr 0,,el.n1-1 ori${or}/alpha rho -err ori${or}sd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*rho.min-rho.max)/2 (3*rho.max-rho.min)/2 lin
yl (5*orial.min-orial.max)/4 (5*orial.max-orial.min)/4 lin

xtext \$\phi\$
ytext \$O_${or}/\alpha\$


latexps ${TP}/${FI}/ori/oblate/ori${or}al_phi/ori${or}al_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig c

cal xrho rho-cg*energy^(-0.5*h/q)

gr 0,,el.n1-1 ori${or} rho-cg*energy^(-0.5*h/q) -err ori${or}sd -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (5*yori${or}.min-yori${or}.max)/4 (5*yori${or}.max-yori${or}.min)/4 lin

xtext \$\phi_{eff}\$
ytext \$O_${or}\$

latexps ${TP}/${FI}/ori/oblate/ori${or}_phieff/ori${or}_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate


fig d

gr 0,,el.n1-1 ori${or}/alpha rho-cg*energy^(-0.5*h/q) -err ori${or}sd/alpha -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 6500-#*500 -text "\${\scriptstyle \alpha=%6.2f}\$" el[#]

gr el.n1 -mark 5500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]
gr el.n1+1 -mark 5500 6000 -text "\${\scriptstyle m=%g,~ \dot{\gamma}=%g}\$" m[0] gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (5*orial.min-orial.max)/4 (5*orial.max-orial.min)/4 lin

xtext \$\phi_{eff}\$
ytext \$O_${or}/\alpha\$


latexps ${TP}/${FI}/ori/oblate/ori${or}al_phieff/ori${or}al_phieff_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
				) > ${PL}/ori_el/oblate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # orientation plot file
				( plo < ${PL}/ori_el/oblate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
				echo d >> ${PL}/ori_el/oblate/ori${or}_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			done

			# grc_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha>1)
cal ygrc select(grc,alpha>1)


fig a

gr 0,,el.n1-1 grc rho -err grc? -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr el.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr el.n1+3 -mark 500 5000 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*ygrc.min-ygrc.max)/18 (19*ygrc.max-ygrc.min)/18 lin

xtext \$\phi\$
ytext \$g^{RC}\$

latexps ${TP}/${FI}/grc_phi_el/prolate/grc_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/grc_el/prolate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # rotational and centre of mass velocity ratio at contact plot file
			( plo < ${PL}/grc_el/prolate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/grc_el/prolate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# grc_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha<1)
cal ygrc select(grc,alpha<1)


fig a

gr 0,,el.n1-1 grc rho -err grc? -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f}\$" N[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle k_d=%g}\$" kd[0]
gr el.n1+2 -mark 500 5500 -text "\${\scriptstyle m=%g}\$" m[0]
gr el.n1+3 -mark 500 5000 -text "\${\scriptstyle \dot{\gamma}=%g}\$" gdot[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*ygrc.min-ygrc.max)/18 (19*ygrc.max-ygrc.min)/18 lin

xtext \$\phi\$
ytext \$g^{RC}\$

latexps ${TP}/${FI}/grc_phi_el/oblate/grc_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/grc_el/oblate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # rotational and centre of mass velocity ratio at contact plot file
			( plo < ${PL}/grc_el/oblate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/grc_el/oblate/grc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# vijrc_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

cal vijrc sqrt(rvij2/cvij2)

cal xrho select(rho,alpha>1)
cal yvijrc select(vijrc,alpha>1)


fig a

gr 0,,el.n1-1 vijrc rho -err 0 -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yvijrc.min-yvijrc.max)/18 (19*yvijrc.max-yvijrc.min)/18 lin

xtext \$\phi\$
ytext \$v^R_{ij}/v^C_{ij}\$

latexps ${TP}/${FI}/vijrc_phi_el/prolate/vijrc_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/vijrc_el/prolate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # rotational and centre of mass velocity ratio at contact plot file
			( plo < ${PL}/vijrc_el/prolate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/vijrc_el/prolate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# vijrc_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`

cal vijrc sqrt(rvij2/cvij2)

cal xrho select(rho,alpha>1)
cal yvijrc select(vijrc,alpha>1)


fig a

gr 0,,el.n1-1 vijrc rho -err 0 -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yvijrc.min-yvijrc.max)/18 (19*yvijrc.max-yvijrc.min)/18 lin

xtext \$\phi\$
ytext \$v^R_{ij}/v^C_{ij}\$

latexps ${TP}/${FI}/vijrc_phi_el/oblate/vijrc_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/vijrc_el/oblate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # rotational and centre of mass velocity ratio at contact plot file
			( plo < ${PL}/vijrc_el/oblate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/vijrc_el/oblate/vijrc_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# S2_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha>1)
cal yS2 select(nemS2,alpha>1)

`_plo_peak nemS2 rho el alpha`


fig a

gr 0,,el.n1-1 nemS2 rho -err 0 -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

icol yy
for i 1000*(19*yS2.min-yS2.max)/18 1000*(19*yS2.max-yS2.min)/18 get i/1000
gr el.n1 yy peak -Dash
gr el.n1 -mark 7300 6500 -text "\${\scriptstyle \phi=%2.3f}\$" peak

gr el.n1+1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+2 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yS2.min-yS2.max)/18 (19*yS2.max-yS2.min)/18 lin

xtext \$\phi\$
ytext \$S_2\$

latexps ${TP}/${FI}/S2_phi_el/prolate/S2_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/S2_el/prolate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # biggest eigenvalue of the order tensor plot file
			( plo < ${PL}/S2_el/prolate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/S2_el/prolate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# S2_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/ltot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.ltot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha<1)
cal yS2 select(nemS2,alpha<1)


fig a

gr 0,,el.n1-1 nemS2 rho -err 0 -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+#*500 -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle \dot{\gamma}=%g,~ m=%g}\$" gdot[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle N=%6.0f,~ k_d=%g}\$" N[0] kd[0]

xl (3*xrho.min-xrho.max)/2 (3*xrho.max-xrho.min)/2 lin
yl (19*yS2.min-yS2.max)/18 (19*yS2.max-yS2.min)/18 lin

xtext \$\phi\$
ytext \$S_2\$

latexps ${TP}/${FI}/S2_phi_el/oblate/S2_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/S2_el/oblate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # biggest eigenvalue of the order tensor plot file
			( plo < ${PL}/S2_el/oblate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/S2_el/oblate/S2_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

			# omegav_phi_*_KD*_M*_GD*_prolate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.tot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el > 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha>1)
cal yomegav select(omega/vr,alpha>1)


fig a

gr 0,,el.n1-1 omega/vr rho -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle \dot\gamma=%g}\$" gdot[0]

xl (4*xrho.min-xrho.max)/3 (4*xrho.max-xrho.min)/3 lin
yl (4*yomegav.min-yomegav.max)/3 (4*yomegav.max-yomegav.min)/3 lin

xtext \$\phi\$
ytext \$\omega/v\$

latexps ${TP}/${FI}/omegav/omegav_phi_el/prolate/omegav_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate
EOF2
			) > ${PL}/omegav_el/prolate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo # ratio of rotational and translational velocities plot file
			( plo < ${PL}/omegav_el/prolate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo ) &> /dev/null
			echo d >> ${PL}/omegav_el/prolate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_prolate.plo

			# omegav_phi_*_KD*_M*_GD*_oblate.plo

			( cat <<EOF2
< "cat ${TP}/tot/${NU}_*_GD${GD[$gd]}_KD${K}_M${MA}_*.tot

icol el
`for el in ${EL[@]}; do if $(python -c "print(['false','true'][$el < 1])"); then echo $el; fi; done`

cal xrho select(rho,alpha<1)
cal yomegav select(omega/vr,alpha<1)


fig a

gr 0,,el.n1-1 omega/vr rho -line -sel alpha=el[#]
gr 0,,el.n1-1 -mark 500 500+500*# -text "\${\scriptstyle \alpha=%1.2f}\$" el[#]

gr el.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g}\$" N[0] kd[0] m[0]
gr el.n1+1 -mark 500 6000 -text "\${\scriptstyle \dot\gamma=%g}\$" gdot[0]

xl (4*xrho.min-xrho.max)/3 (4*xrho.max-xrho.min)/3 lin
yl (4*yomegav.min-yomegav.max)/3 (4*yomegav.max-yomegav.min)/3 lin

xtext \$\phi\$
ytext \$\omega/v\$

latexps ${TP}/${FI}/omegav/omegav_phi_el/oblate/omegav_phi_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate
EOF2
			) > ${PL}/omegav_el/oblate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo # ratio of rotational and translational velocities plot file
			( plo < ${PL}/omegav_el/oblate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo ) &> /dev/null
			echo d >> ${PL}/omegav_el/oblate/omegav_${NU}_KD${K}_M${MA}_GD${GD[$gd]}_oblate.plo

		fi

	done

	# omegav_phiJ_*_KD*_M*.plo

	GD_=( `( plo <<EOF2
< ${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.out
list gdot
EOF2
	) | grep -v Plo` ) # shear rates which have been analysed in the data file...
	GD_=($(for gd in ${GD_[@]}; do echo $gd; done | sort)) # ...sorted
	GD=() # shear rates which have been analysed in the data file without repetition
	for gd in ${GD_[@]}; do
		if [[ ! "${GD[@]}" =~ $gd ]]; then
			GD+=($gd)
		fi
	done
	( cat <<EOF2
< ${TP}/${OV}/omegav_phiJ_${NU}_KD${K}_M${MA}.out

cal N $NU
cal kd $K
cal m $MA

icol gd
`for gd in ${GD[@]}; do echo $gd; done`


fig a

gr 0,,gd.n1-1 omegav_phiJ alpha -line -sel gdot=gd[#]
gr 0,,gd.n1-1 -mark 500+500*#500 -text "\${\scriptstyle \dot\gamma=%g}\$" gd[#]

gr gd.n1 -mark 500 6500 -text "\${\scriptstyle N=%6.0f,~ k_d=%g,~ m=%g}\$" N kd m

xtext \$\phi\$
ytext \$<\omega/v>_{\phi>\phi_J(\alpha)}\$

latexps ${TP}/${FI}/omegav_phiJ/omegav_phiJ_alpha_${NU}_KD${K}_M${MA}
EOF2
	) > ${PL}/omegav_phiJ/omegav_phiJ_${NU}_KD${K}_M${MA}.plo # mean of the ratio of rotational and translational velocities above the jamming packing fraction
	( plo < ${PL}/omegav_phiJ/omegav_phiJ_${NU}_KD${K}_M${MA}.plo ) &> /dev/null
	echo d >> ${PL}/omegav_phiJ/omegav_phiJ_${NU}_KD${K}_M${MA}.plo

EOF

mkdir -p $LP

printf "\n"

echo "Copying new critical exponents data files from tp.umu.se to local."
mkdir -p ${LP}/${CR}
rsync --quiet --exclude '*~' -avzhe ssh ${LA}:${TP}/${CR}/ ${LP}/${CR} # copies new critical exponents data files to local

echo "Copying new contact numbers data files from tp.umu.se to local."
mkdir -p ${LP}/${ZR}
rsync --quiet --exclude '*~' -avzhe ssh ${LA}:${TP}/${ZR}/ ${LP}/${ZR} # copies new contact numbers data files to local

echo "Copying new ratio of rotational and translational velocities data files from tp.umu.se to local."
mkdir -p ${LP}/${OV}
rsync --quiet --exclude '*~' -avzhe ssh ${LA}:${TP}/${OV}/ ${LP}/${OV} # copies new ratio of rotational and translational velocities data files to local

echo "Copying new plo scripts from tp.umu.se to local."
mkdir -p ${LP}/${PL}
rsync --quiet --exclude '*~' -avzhe ssh ${LA}:${TP}/${PL}/ ${LP}/${PL} # copies new plotting files to local

echo "Copying new figures from tp.umu.se to local."
mkdir -p ${LP}/${FI}
rsync --quiet --exclude '*~' -avzhe ssh ${LA}:${TP}/${FI}/ ${LP}/${FI} # copies new figures to local
